# Simple Shell Project

Hey there! ðŸ‘‹ Welcome to our second project in the ALX SE foundations - the Simple Shell project!

## Overview

In this adventure, we're diving into the world of shell programming. The project is divided into two parts: the must-do tasks and the extra cool stuff.

### Mandatory Tasks:

1. **UNIX Command Line Interpreter:** Yep, we're building our own!
2. **Tokenize:** Because handling words is our thing.
3. **Handle PATH:** Navigating the system like a pro.
4. **Built-in Command Exit:** Exiting with style.
5. **Built-in Command Env:** Because environment matters.

### Advanced Tasks:

6. **Our Personal Getline Function:** A touch of personalization.
7. **Our Personal Strtok Function:** Who needs standard when you can roll your own?
8. **Built-in Command Exit with Argument:** Say goodbye with a message.
9. **Built-in Commands Setenv and Unsetenv:** Tweaking the environment.
10. **Built-in Command CD:** Navigating home.
11. **Handle Separator ;:** Because we love to keep things separate.
12. **Handle Logical Operators && and ||:** Thinking logically.
13. **Built-in Command Alias:** Because nicknames are cool.
14. **Handle Variables Replacement $? and $$:** Playing with variables.
15. **Handle Comments (#):** Because sometimes, you just want to comment.
16. **File as Input:** Reading from a file.

## How We Got Here

Now, let's spill the beans on how we tackled this challenge!

This project has includes everything that we've learned so far in our ALX journey. It was like a big, messy puzzle of concepts we've studied before. But hey, that's the fun part, right?

Before diving in, we needed to wrap our heads around what a shell is and how it works. Understanding the basics set us on the right path.

For our first step, we:

1. Read commands from stdin using `getline` function.
2. Displayed the prompt with an endless loop - because we love loops!
3. Split commands (tokenizing) using `strtok`.
4. Went on a quest for executable commands in PATH.
5. Created a mini-me (child process) with `fork`.
6. Executed the command with a grand finale using `exec`.
7. Waited patiently for the child to complete with `waitpid`.
8. Displayed the output, returned the prompt, and gracefully exited with a wave or a Ctrl+D dance.

This framework laid the foundation for us to easily add more cool features based on the tasks at hand.

## Overall Experience

this project was a rollercoaster of learning. We teamed up, we delved deep into the intricacies of shells, faced challenges head-on, and emerged with a newfound understanding. It was tough but incredibly rewarding - a journey worth taking.

Ready to explore your own shell adventures? Dive in and happy coding! ðŸš€âœ¨

